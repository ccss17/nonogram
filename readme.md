# nonogram

## Philosophy

### Idea

#### Definition 

- **패턴(Pattern)** : 키 값으로 정해지는 라인의 모양

  - 예시 : 키 값이 `"2 1"` 이고 라인의 길이가 `5` 일때 정해질 수 있는 패턴 중 하나는 `"ooxox"` 이다. 

- **패턴의 집합(Set of pattern)** : 패턴의 모든 경우의 집합 

  - 예시 : 키 값이 `"2 1"` 이고 라인의 길이가 `5` 일때 패턴은 집합 `{"ooxox", "ooxxo", "xooxo"}` 이다. 

- **패턴의 복잡도(Complexity of pattern)** : 패턴이 지니는 원소의 개수 

  - 예시 : 위의 예시에서 패턴의 복잡도는 `3` 이다. 

- **패턴의 교집합(Consensus of pattern)** : 패턴이 지니는 모든 원소들이 공통적으로 갖고 있는 동일한 블록들의 위치정보와 상태정보를 가진 집합 

  - 예시 : 위의 예시에서 패턴의 교집합은 `"?o???"` 이다. 

- **패턴의 축소(Reduction of pattern)** : 결정된 블록에 근거하여 존재하지 않는 패턴을 을 삭제하는 것.  

  - 예시 : 위의 예시에서 결정된 블록이 `"???x?"` 이라 할 때 패턴은 집합 `{"ooxxo", "xooxo"}` 으로 축소된다. 

- **패턴의 교집합의 확장(Expansion of consensus of pattern)** : 패턴의 축소로 인하여 패턴이 공통적으로 갖는 동일한 블록들이 늘어난 것 

  - 예시 : 위의 예시에서 결정된 블록이 `"???x?"` 이라 할 때 패턴은 집합 `{"ooxxo", "xooxo"}` 으로 축소되었다. 이때 패턴의 교집합은 `"?o???"` 에서 `"?o?xo"` 으로 확장된다. 

#### Solution

- (1) **네모로직의 생성** : 키 값으로 패턴이 결정된다. 

  - 그런데 패턴은 여러 형태를 가질 수 있기 때문에 라인의 블록들이 한번에 결정되지 않는다.

  - 만약 모든 패턴 형태가 동의하는 교집합이 존재하지 않으면 네모로직을 풀 수 없다.(증명 필요)
  
  - 하지만 풀 수 있는 네모로직은 모든 패턴 형태가 동의하는 교집합이 존재한다. 

- (2) **패턴의 교집합 찾기** : 모든 패턴 형태가 동의하는 교집합으로 라인의 일부 블록을 결정할 수 있다. 

- (3) **다른 라인의 패턴 축소** : 블록이 결정되면 그 블록을 포함하는 다른 라인의 패턴이 축소되고 이에 따라 해당 라인의 패턴의 교집합이 확장된다. 

- (4) **2 와 3의 반복** : 다른 라인의 교집합이 확장되었다면 다시 라인의 일부 블록을 결정할 수 있고 결정된 블록을 포함하는 다른 라인의 패턴이 축소된다. 이에 따라 또 다시 해당 라인의 패턴의 교집합이 확장된다. 

- (5) 이때 다음 반복로직은 패턴의 복잡도가 `1` 이 될 때 끝나며 그 시점에서 네모로직은 풀려있게 된다. 

  - 반복로직 : **(패턴의 교집합 찾기)** &rarr; **(다른 라인의 패턴 축소)** &rarr; **(패턴의 교집합 찾기)** &rarr; **(다른 라인의 패턴 축소)** &rarr; ... 

#### Further discussion

- 패턴의 복잡도가 패턴의 교집합에 비례하는가?

  - **배경** : 패턴의 교집합이 가장 큰 것부터 풀이를 시작해나가야 한다. 그런데 여러 패턴의 교집합이 발생하였을 때 어느 패턴부터 시작해야 풀이가 가장 간단해질까? 그것은 패턴의 교집합이 가장 큰 것부터 시작하는 것이다. 왜냐하면 교집합이 클 수록 영향을 받아 패턴의 축소가 발생하는 라인의 개수가 많아지기 때문이다. 이에따라 패턴의 교집합이 작은 것부터 풀이를 시작하는 것보다 전체적인 패턴의 복잡도의 총량이 더 낮아진다. 

  - **설명** : 그러므로 패턴의 교집합이 가장 큰 것을 비교하여 구해야 한다. 그런데 만약 패턴의 복잡도가 패턴의 교집합과 비례한다면 모든 패턴의 교집합까지 구할 필요 없이 패턴의 복잡도까지만 구한 시점에서 복잡도로 비교를 할 수 있게 된다. 이렇게 하면 절차가 한 단계 짧아지는 효과가 발생하여 풀이가 끝나는 전체 시간도 짧아진다. 

  - **반례** : 만약 패턴의 복잡도가 작아도 패턴의 교집합이 더 작을 수도 있다고 가정하자. 예를 들어 `n` 번째 라인의 패턴의 복잡도가 `2` 이고 교집합의 개수가 `1` 이라고 생각하자. 또 `m` 번째 라인의 패턴의 복잡도가 `3` 이고 교집합의 개수가 `2` 라고 가정해보자. 이 가정이 불가능하지 않다면 패턴의 복잡도는 패턴의 교집합의 개수와 비례하지 않는다. 

  - **반례의 증명** : 라인 `n` 은 패턴의 복잡도가 `2` 이고 교집합의 개수는 `1` 이다. 그러므로 패턴 `{"oooox", "xxxxx"}` 을 갖다고 생각하자. 라인 `m` 은 패턴의 복잡도가 `3` 이고 교집합의 개수는 `2` 이다. 그러므로 패턴 `{"oooxx", "xxxxx", "oxoxx"}` 갖는다고 생각하자. 그러면 라인 `n` 은 `"????x"` 라는 교집합을 갖고 라인 `m` 은 `"???xx"` 라는 교집합을 갖는다. 

  - **결론** : 라인의 패턴의 복잡도가 낮다고 해서 교집합의 개수가 반드시 많은 것은 아니다. (그러므로 항상 패턴의 교집합까지 구해서 비교해야 한다.)

- 만약 패턴의 교집합이 존재하지 않는다면 패턴의 집합에서 임의로 패턴 몇 개를 제거하여 패턴의 교집합을 강제로 축소하여 네모로직의 실질적 풀이를 진행시킬 수 있나?

  - 패턴의 교집합이 존재하지 않는다면 강제로 임의의 패턴 몇 개를 제거하여 풀이를 진행해야 하고 이때 네모로직의 전체 모양이 여러 경우의 수로 나뉠 수 있다. 

- 여러 패턴의 교집합이 발생하였을 때 먼저 처리해야 하는 패턴

  - 만약 여러 패턴에 교집합이 발생하였 

- 키 값으로 패턴이 어떻게 결정되는가?

  - ~~**단순화에 관하여** : 문제나 상황, 현상을 할 수 있는데까지 최대한 단순화시키는 것은 매우 중요한데 왜냐하면 불변요소와 가변요소를 결정한 시점에서 불변요소를 사고대상영역에서 제외시킬 수 있기 때문이다. 이렇게 되면 불변요소가 사라져서 좀 더 가벼워지고 단순해진 사고대상영역을 볼 수 있다. 그러면 생각을 진행시키기 훨씬 수월해진다. 또한 비록 문제와 상황의 논리가 허용하는 단순화가 아니라 할지라도 실험자가 임의로 가변요소를 불변요소로 정하여 강제로 단순화를 시키고 사고를 진행할 수도 있다. 이렇게 강제 단순화로 이끌어낸 진리에 대하여서는 "어떤 조건 하에서는 참이다" 또는 "어떤 조건 하에서 적용된다" 라고 하면 되기 때문이다.~~

  - **키 값** : 네모로직에서 키 값이란 특정 자연수로 이루어진 수열이다. 이 수열은 일정한 길이와 일정한 개수의 빈 칸이 그려저 있는 테이프에 적용된다. 적용되는 방식은 수열의 숫자만큼 테이프의 빈칸에 연속으로 색깔이 칠해지고 수열의 숫자들 사이에는 반드시 빈칸이 하나 이상 있어서 연속적으로 칠해진 블록들을 떨어뜨려놓는다. 

  - **단순화** : 그런데 색을 칠한다는 것은 단지 수열의 숫자에 대응하는 수만큼 칸에 색을 칠한다는 것이다. 그러므로 `n` 개의 칸에 색을 칠하는 것을 숫자 `n` 에 대응시키면 항상 그것을 특정 할 수 있다. 이제 여기에서 칠해진 칸을 검은색 칸이라 하고 빈 칸을 하얀색 칸이라고 정의해도 본질적 의미가 훼손되지 않기 때문에 그렇게 단순화시키자. 그러면 검은색 칸 사이에 반드시 하얀색 칸이 하나 이상 있어야 한다. 또한 검은색 칸 사이의 하얀색 칸이 항상 왼쪽 검은색 칸에 붙어있다고 생각해도 본질적 의미에 훼손이 간다고 생각되지 않기 때문에 그렇게 단순화시키자. 

  - **불변요소** : 그러므로 여기까지 논의한 시점에서 검은색 칸의 상대적 위치와 검은색 칸들 사이의 왼쪽에 항상 붙어있는 `1` 개의 하얀색 칸을 생각할 수 있고, 이것은 키 값에 따른 불변요소이다. 그러므로 이제 사고대상영역에서 불변요소를 제외시킬 수 있다. 

  - **몇 가지 정의** : 칸은 특정한 색으로 칠해진 테이프 한 칸을 뜻한다. 블록은 그 칸들이 연속적으로 모여있는 것을 뜻한다. 

  - **가변요소** : 테이프의 빈 칸의 총 개수가 `n` 개라 하고 검은색 블록의 개수가 `m` 개, 검은색 칸의 총합을 `l`, 하얀색 칸의 총합이 `k` 이라고 하자. 그러면 `n` 의 길이를 갖는 수열은 `m` 개의 블록들과 `k` 개의 칸들의 조합이라고 생각할 수 있다. 그런데 `m` 개의 검은색 블록들을 이미 정해져 있고 검은색 블록들 사이의 왼쪽에 하얀색 칸이 반드시 `1` 개 붙어있다는 것을 알고 있다. 

### Policy

#### Definition 

  - 키 값의 개수 = `len(k)`

  - 키 값 = `k`

  - 첫번째 키 값 = `k[0]`

  - 마지막 키 값 = `k[len(k)-1]`

  - 키 값의 합 = `sum(k)`

  - 칸 수 = `n`

  - 이미 칠해진 칸 수 = `m`

  - 칸 전체를 O 으로 칠하기 = `line_on()`

  - 칸 전체를 X 으로 칠하기 = `line_off()`

  - 칠해지지 않은 칸을 O 으로 칠하기 = `remain_on()`

  - 칠해지지 않은 칸을 X 로 칠하기 = `remain_off()`

#### Pattern decision algorithm

  1. 

#### Tirivial algorithm

  1. `if (sum(k) + len(k) - 1 == n) line()`

  2. `if (len(k) == 1) if (m == k[0]) remain_off()`