# nonogram

## Philosophy

### Idea

#### Definition 

- **패턴(Pattern)** : 키 값으로 정해지는 라인의 모양

  - 예시 : 키 값이 `"2 1"` 이고 라인의 길이가 `5` 일때 정해질 수 있는 패턴 중 하나는 `"ooxox"` 이다. 

- **패턴의 집합(Set of pattern)** : 패턴의 모든 경우의 집합 

  - 예시 : 키 값이 `"2 1"` 이고 라인의 길이가 `5` 일때 패턴은 집합 `{"ooxox", "ooxxo", "xooxo"}` 이다. 

- **패턴의 복잡도(Complexity of pattern)** : 패턴이 지니는 원소의 개수 

  - 예시 : 위의 예시에서 패턴의 복잡도는 `3` 이다. 

- **패턴의 교집합(Consensus of pattern)** : 패턴이 지니는 모든 원소들이 공통적으로 갖고 있는 동일한 블록들의 위치정보와 상태정보를 가진 집합 

  - 예시 : 위의 예시에서 패턴의 교집합은 `"?o???"` 이다. 

- **패턴의 축소(Reduction of pattern)** : 결정된 블록에 근거하여 존재하지 않는 패턴을 을 삭제하는 것.  

  - 예시 : 위의 예시에서 결정된 블록이 `"???x?"` 이라 할 때 패턴은 집합 `{"ooxxo", "xooxo"}` 으로 축소된다. 

- **패턴의 교집합의 확장(Expansion of consensus of pattern)** : 패턴의 축소로 인하여 패턴이 공통적으로 갖는 동일한 블록들이 늘어난 것 

  - 예시 : 위의 예시에서 결정된 블록이 `"???x?"` 이라 할 때 패턴은 집합 `{"ooxxo", "xooxo"}` 으로 축소되었다. 이때 패턴의 교집합은 `"?o???"` 에서 `"?o?xo"` 으로 확장된다. 

#### Solution

- (1) **네모로직의 생성** : 키 값으로 패턴이 결정된다. 

  - 그런데 패턴은 여러 형태를 가질 수 있기 때문에 라인의 블록들이 한번에 결정되지 않는다.

  - 만약 모든 패턴 형태가 동의하는 교집합이 존재하지 않으면 네모로직을 풀 수 없다.(증명 필요)
  
  - 하지만 풀 수 있는 네모로직은 모든 패턴 형태가 동의하는 교집합이 존재한다. 

- (2) **패턴의 교집합 찾기** : 모든 패턴 형태가 동의하는 교집합으로 라인의 일부 블록을 결정할 수 있다. 

- (3) **다른 라인의 패턴 축소** : 블록이 결정되면 그 블록을 포함하는 다른 라인의 패턴이 축소되고 이에 따라 해당 라인의 패턴의 교집합이 확장된다. 

- (4) **2 와 3의 반복** : 다른 라인의 교집합이 확장되었다면 다시 라인의 일부 블록을 결정할 수 있고 결정된 블록을 포함하는 다른 라인의 패턴이 축소된다. 이에 따라 또 다시 해당 라인의 패턴의 교집합이 확장된다. 

- (5) 이때 다음 반복로직은 패턴의 복잡도가 `1` 이 될 때 끝나며 그 시점에서 네모로직은 풀려있게 된다. 

  - 반복로직 : **(패턴의 교집합 찾기)** &rarr; **(다른 라인의 패턴 축소)** &rarr; **(패턴의 교집합 찾기)** &rarr; **(다른 라인의 패턴 축소)** &rarr; ... 

#### Further discussion

- **가정(Assumption)** : 패턴의 복잡도가 패턴의 교집합에 비례하는가?

  - **배경(Background)** : 패턴의 교집합이 가장 큰 것부터 풀이를 시작해나가야 한다. 그런데 여러 패턴의 교집합이 발생하였을 때 어느 패턴부터 시작해야 풀이가 가장 간단해질까? 그것은 패턴의 교집합이 가장 큰 것부터 시작하는 것이다. 왜냐하면 교집합이 클 수록 영향을 받아 패턴의 축소가 발생하는 라인의 개수가 많아지기 때문이다. 이에따라 패턴의 교집합이 작은 것부터 풀이를 시작하는 것보다 전체적인 패턴의 복잡도의 총량이 더 낮아진다. 

  - **설명(Description)** : 그러므로 패턴의 교집합이 가장 큰 것을 비교하여 구해야 한다. 그런데 만약 패턴의 복잡도가 패턴의 교집합과 비례한다면 모든 패턴의 교집합까지 구할 필요 없이 패턴의 복잡도까지만 구한 시점에서 복잡도로 비교를 할 수 있게 된다. 이렇게 하면 절차가 한 단계 짧아지는 효과가 발생하여 풀이가 끝나는 전체 시간도 짧아진다. 

  - **반례(Counterexample)** : 만약 패턴의 복잡도가 작아도 패턴의 교집합이 더 작을 수도 있다고 가정하자. 예를 들어 `n` 번째 라인의 패턴의 복잡도가 `2` 이고 교집합의 개수가 `1` 이라고 생각하자. 또 `m` 번째 라인의 패턴의 복잡도가 `3` 이고 교집합의 개수가 `2` 라고 가정해보자. 이 가정이 불가능하지 않다면 패턴의 복잡도는 패턴의 교집합의 개수와 비례하지 않는다. 

  - **반례의 증명(Proof of Counterexample)** : 라인 `n` 은 패턴의 복잡도가 `2` 이고 교집합의 개수는 `1` 이다. 그러므로 패턴 `{"oooox", "xxxxx"}` 을 갖다고 생각하자. 라인 `m` 은 패턴의 복잡도가 `3` 이고 교집합의 개수는 `2` 이다. 그러므로 패턴 `{"oooxx", "xxxxx", "oxoxx"}` 갖는다고 생각하자. 그러면 라인 `n` 은 `"????x"` 라는 교집합을 갖고 라인 `m` 은 `"???xx"` 라는 교집합을 갖는다. 

  - **결론(Conclusion)** : 라인의 패턴의 복잡도가 낮다고 해서 교집합의 개수가 반드시 많은 것은 아니다. (그러므로 항상 패턴의 교집합까지 구해서 비교해야 한다.)

- 만약 패턴의 교집합이 존재하지 않는다면 네모로직을 풀 수 없는가? 이 경우 패턴의 집합에서 임의로 패턴 몇 개를 제거하여 패턴의 교집합을 강제로 축소한다면, 네모로직의 실질적 풀이를 진행시킬 수 있는가? 임의로 패턴을 제거하였기 때문에 풀이를 진행하다 보면 언젠가 불확실하다는 결론에 봉착하지 않을까? 

  - 일단 패턴의 교집합이 항상 존재한다고 가정하고 이 교집합을 중심으로 네모로직을 푸는 코딩을 해봐야겠다. 

- 여러 패턴의 교집합이 발생하였을 때 먼저 처리해야 하는 패턴

  - 만약 여러 패턴에 교집합이 발생하였 

### Policy

#### Definition 

  - 키 값의 개수 = `len(k)`

  - 키 값 = `k`

  - 첫번째 키 값 = `k[0]`

  - 마지막 키 값 = `k[len(k)-1]`

  - 키 값의 합 = `sum(k)`

  - 칸 수 = `n`

  - 이미 칠해진 칸 수 = `m`

  - 칸 전체를 O 으로 칠하기 = `line_on()`

  - 칸 전체를 X 으로 칠하기 = `line_off()`

  - 칠해지지 않은 칸을 O 으로 칠하기 = `remain_on()`

  - 칠해지지 않은 칸을 X 로 칠하기 = `remain_off()`

#### Pattern decision algorithm

  1. 

#### Tirivial algorithm

  1. `if (sum(k) + len(k) - 1 == n) line()`

  2. `if (len(k) == 1) if (m == k[0]) remain_off()`